
/*
 * File Name : tinycbor_test.c
 *
 * Purpose :
 *
 * Creation Date : 24-08-2020
 *
 * Last Modified : Wednesday 23 September 2020 02:15:21 AM IST
 *
 * Created By : Nabendu maiti 
 *
 */

#include "src/cbor.h"

#include <sys/stat.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>



typedef struct {
	uint8_t *sdata;
	size_t size;
}cbor_stream_t;


int tinycbor_main(void);
cbor_stream_t * test_encode(void);
int test_decode(cbor_stream_t *stream);


uint8_t b_sample_16[] = {
0x5e, 0x6e, 0x57, 0xe4, 0x43, 0x7a, 0x08, 0xc3, 0xb3, 0xfd, 0x16, 0xbd, 0x60, 0xf8, 0xbc, 0x5c
};

uint8_t b_sample_256[] = {
0x5e, 0x6e, 0x57, 0xe4, 0x43, 0x7a, 0x08, 0xc3, 0xb3, 0xfd, 0x16, 0xbd, 0x60, 0xf8, 0xbc, 0x5c,
0xe7, 0xa7, 0xaa, 0xf1, 0xd6, 0x6e, 0x9c, 0x73, 0x67, 0x82, 0x60, 0xbe, 0xfc, 0xf8, 0xdb, 0x54,
0xb8, 0x87, 0xf2, 0xc4, 0xd8, 0x7a, 0x8e, 0x19, 0x1c, 0xcc, 0xdb, 0x6e, 0x9f, 0x43, 0xb2, 0xd9,
0xf4, 0xc1, 0x75, 0x82, 0x45, 0x1e, 0xbe, 0x15, 0x7e, 0xe1, 0x29, 0xc7, 0x42, 0xad, 0xb2, 0xb1,
0x12, 0x60, 0x05, 0x0b, 0x38, 0x11, 0xc0, 0x83, 0xd5, 0x28, 0x8f, 0x8c, 0x58, 0xb8, 0x21, 0xf0,
0xd2, 0x2c, 0xf9, 0x43, 0x2d, 0x60, 0x8f, 0x65, 0xc5, 0xfd, 0x6e, 0xf6, 0x9f, 0x7b, 0x14, 0x4f,
0x1d, 0xf0, 0x4a, 0x07, 0xc6, 0x6f, 0xa4, 0x43, 0x60, 0x56, 0xae, 0x19, 0xdc, 0x1c, 0x0b, 0xd2,
0x11, 0x45, 0xcb, 0xd4, 0x18, 0xc5, 0x01, 0xb9, 0x9c, 0x7d, 0x05, 0xd0, 0xa6, 0xed, 0xa5, 0x5b,
0x6c, 0x9c, 0xa7, 0x03, 0x9b, 0x3c, 0xcd, 0x4c, 0xb9, 0x93, 0xbe, 0x1f, 0xad, 0x21, 0xfc, 0xc9,
0x33, 0x40, 0xe7, 0xc5, 0x53, 0x0d, 0xac, 0xee, 0x67, 0x9f, 0x32, 0x7c, 0x3d, 0x42, 0x87, 0x02,
0x92, 0x35, 0x29, 0x4c, 0xe3, 0x33, 0x5a, 0xa9, 0x2a, 0xae, 0x54, 0x11, 0x63, 0xb7, 0x1e, 0xa1,
0x63, 0xe2, 0xcc, 0xf1, 0x7c, 0x43, 0x18, 0x7d, 0x9e, 0x3a, 0x2f, 0xff, 0x00, 0x47, 0xe2, 0x03,
0xb6, 0x22, 0xd2, 0xd5, 0xdc, 0x77, 0xb6, 0xb5, 0x72, 0x91, 0x52, 0x6c, 0x6b, 0x8c, 0xaf, 0x5e,
0x6c, 0x5b, 0x0e, 0x51, 0x54, 0xa3, 0xc2, 0x6c, 0xca, 0x50, 0x52, 0x35, 0xd7, 0x1d, 0xc2, 0x28,
0x6b, 0x06, 0x1e, 0x8a, 0xb6, 0xaf, 0x2c, 0xb1, 0x09, 0x73, 0x47, 0x26, 0x9c, 0xd6, 0x68, 0x69,
0x05, 0x3c, 0x0b, 0xcc, 0x7c, 0x16, 0xbd, 0x0d, 0x69, 0x97, 0xc7, 0xee, 0x1d, 0x0b, 0xe2, 0x26
};

uint8_t b_sample_272[] = {
0x92, 0x35, 0x29, 0x4c, 0xe3, 0x33, 0x5a, 0xa9, 0x2a, 0xae, 0x54, 0x11, 0x63, 0xb7, 0x1e, 0xa1,
0x5e, 0x6e, 0x57, 0xe4, 0x43, 0x7a, 0x08, 0xc3, 0xb3, 0xfd, 0x16, 0xbd, 0x60, 0xf8, 0xbc, 0x5c,
0xe7, 0xa7, 0xaa, 0xf1, 0xd6, 0x6e, 0x9c, 0x73, 0x67, 0x82, 0x60, 0xbe, 0xfc, 0xf8, 0xdb, 0x54,
0xb8, 0x87, 0xf2, 0xc4, 0xd8, 0x7a, 0x8e, 0x19, 0x1c, 0xcc, 0xdb, 0x6e, 0x9f, 0x43, 0xb2, 0xd9,
0xf4, 0xc1, 0x75, 0x82, 0x45, 0x1e, 0xbe, 0x15, 0x7e, 0xe1, 0x29, 0xc7, 0x42, 0xad, 0xb2, 0xb1,
0x12, 0x60, 0x05, 0x0b, 0x38, 0x11, 0xc0, 0x83, 0xd5, 0x28, 0x8f, 0x8c, 0x58, 0xb8, 0x21, 0xf0,
0xd2, 0x2c, 0xf9, 0x43, 0x2d, 0x60, 0x8f, 0x65, 0xc5, 0xfd, 0x6e, 0xf6, 0x9f, 0x7b, 0x14, 0x4f,
0x1d, 0xf0, 0x4a, 0x07, 0xc6, 0x6f, 0xa4, 0x43, 0x60, 0x56, 0xae, 0x19, 0xdc, 0x1c, 0x0b, 0xd2,
0x11, 0x45, 0xcb, 0xd4, 0x18, 0xc5, 0x01, 0xb9, 0x9c, 0x7d, 0x05, 0xd0, 0xa6, 0xed, 0xa5, 0x5b,
0x6c, 0x9c, 0xa7, 0x03, 0x9b, 0x3c, 0xcd, 0x4c, 0xb9, 0x93, 0xbe, 0x1f, 0xad, 0x21, 0xfc, 0xc9,
0x33, 0x40, 0xe7, 0xc5, 0x53, 0x0d, 0xac, 0xee, 0x67, 0x9f, 0x32, 0x7c, 0x3d, 0x42, 0x87, 0x02,
0x92, 0x35, 0x29, 0x4c, 0xe3, 0x33, 0x5a, 0xa9, 0x2a, 0xae, 0x54, 0x11, 0x63, 0xb7, 0x1e, 0xa1,
0x63, 0xe2, 0xcc, 0xf1, 0x7c, 0x43, 0x18, 0x7d, 0x9e, 0x3a, 0x2f, 0xff, 0x00, 0x47, 0xe2, 0x03,
0xb6, 0x22, 0xd2, 0xd5, 0xdc, 0x77, 0xb6, 0xb5, 0x72, 0x91, 0x52, 0x6c, 0x6b, 0x8c, 0xaf, 0x5e,
0x6c, 0x5b, 0x0e, 0x51, 0x54, 0xa3, 0xc2, 0x6c, 0xca, 0x50, 0x52, 0x35, 0xd7, 0x1d, 0xc2, 0x28,
0x6b, 0x06, 0x1e, 0x8a, 0xb6, 0xaf, 0x2c, 0xb1, 0x09, 0x73, 0x47, 0x26, 0x9c, 0xd6, 0x68, 0x69,
0xd2, 0x2c, 0xf9, 0x43, 0x2d, 0x60, 0x8f, 0x65, 0xc5, 0xfd, 0x6e, 0xf6, 0x9f, 0x7b, 0x14, 0x4f
};

static size_t writefile(uint8_t *data, size_t size)
{
    FILE *f = fopen("output_cbor.bin", "w");
    size_t ret = -1;
	if (!f)
        return -1;

    ret = fwrite(data, size, 1, f);
    fclose(f);
    return ret;
}


static void dumpbytes(const uint8_t *buf, size_t len)
{
    while (len--)
        printf("%02X ", *buf++);
}


static void indent(int nestingLevel)
{
    while (nestingLevel--)
        puts("  ");
}

static CborError dumprecursive(CborValue *it, int nestingLevel)
{
    while (!cbor_value_at_end(it)) {
        CborError err;
        CborType type = cbor_value_get_type(it);

        indent(nestingLevel);
        switch (type) {
        case CborArrayType:
        case CborMapType: {
            // recursive type
            CborValue recursed;
            assert(cbor_value_is_container(it));
            puts(type == CborArrayType ? "Array[" : "Map[");
            err = cbor_value_enter_container(it, &recursed);
            if (err)
                return err;       // parse error
            err = dumprecursive(&recursed, nestingLevel + 1);
            if (err)
                return err;       // parse error
            err = cbor_value_leave_container(it, &recursed);
            if (err)
                return err;       // parse error
            indent(nestingLevel);
            puts("]");
            continue;
        }

        case CborIntegerType: {
            int64_t val;
            cbor_value_get_int64(it, &val);     // can't fail
            printf("%lld\n", (long long)val);
            break;
        }

        case CborByteStringType: {
            uint8_t *buf;
            size_t n;
            err = cbor_value_dup_byte_string(it, &buf, &n, it);
            if (err)
                return err;     // parse error
            dumpbytes(buf, n);
            puts("");
            free(buf);
            continue;
        }

        case CborTextStringType: {
            char *buf;
            size_t n;
            err = cbor_value_dup_text_string(it, &buf, &n, it);
            if (err)
                return err;     // parse error
            puts(buf);
            free(buf);
            continue;
        }

        case CborTagType: {
            CborTag tag;
            cbor_value_get_tag(it, &tag);       // can't fail
            printf("Tag(%lld)\n", (long long)tag);
            break;
        }

        case CborSimpleType: {
            uint8_t type2;
            cbor_value_get_simple_type(it, &type2);  // can't fail
            printf("simple(%u)\n", type2);
            break;
        }

        case CborNullType:
            puts("null");
            break;

        case CborUndefinedType:
            puts("undefined");
            break;

        case CborBooleanType: {
            bool val;
            cbor_value_get_boolean(it, &val);       // can't fail
            puts(val ? "true" : "false");
            break;
        }

        case CborDoubleType: {
            double val;
            if (false) {
                float f;
        case CborFloatType:
                cbor_value_get_float(it, &f);
                val = f;
            } else {
                cbor_value_get_double(it, &val);
            }
            printf("%g\n", val);
            break;
        }
        case CborHalfFloatType: {
            uint16_t val;
            cbor_value_get_half_float(it, &val);
            printf("__f16(%04x)\n", val);
            break;
        }

        case CborInvalidType:
		default:
            assert(false);      // can't happen
            break;
        }

        err = cbor_value_advance_fixed(it);
        if (err)
            return err;
    }
    return CborNoError;
}


#define OUT_BUFF_SIZE 2048
uint8_t out[OUT_BUFF_SIZE];

cbor_stream_t * test_encode(void)
{
    CborEncoder enc;

	// Encode
	cbor_stream_t *enc_data = (cbor_stream_t *)malloc(sizeof(cbor_stream_t));
    cbor_encoder_init(&enc, out, OUT_BUFF_SIZE, 0);

	CborEncoder map;
    cbor_encoder_create_map(&enc, &map, 3);

    cbor_encode_int(&map, 66);
    cbor_encode_int(&map, 1245);

    cbor_encode_int(&map, 44);
    cbor_encode_int(&map, 9845);

    cbor_encode_int(&map, 333);
    CborEncoder ary;
    cbor_encoder_create_array(&map, &ary, 5);

    cbor_encode_int(&ary, 55);
    cbor_encode_byte_string(&ary, b_sample_16, sizeof(b_sample_16));
    cbor_encode_byte_string(&ary, b_sample_256, sizeof(b_sample_256));
    cbor_encode_byte_string(&ary, b_sample_272, sizeof(b_sample_272));
    cbor_encode_float(&ary, 3.14);

    cbor_encoder_close_container(&map, &ary);

    cbor_encoder_close_container(&enc, &map);

	enc_data->sdata = out;
	enc_data->size = cbor_encoder_get_buffer_size(&enc, out);

    return enc_data;
}


int test_decode(cbor_stream_t *stream)
{
    uint8_t *buf = stream->sdata;
    size_t length = stream->size;
	CborParser parser;
    CborValue it;

	CborError err = cbor_parser_init(buf, length, 0, &parser, &it);
    if (!err)
        err = dumprecursive(&it, 0);

    if (err) {
        fprintf(stderr, "CBOR parsing failure at offset %ld: %s\n",
                it.ptr - buf, cbor_error_string(err));
        return 1;
    }
	return 0;
}


int tinycbor_main(void)
{
	int ret = -1;
	cbor_stream_t *encoded_stream =NULL;

	{
    	printf("Creating cbor stream from sample data\n");
		/* Nof cbor file to decode */
		encoded_stream = test_encode();
		if (encoded_stream == NULL) {
			return ret;
		}
		writefile(encoded_stream->sdata, encoded_stream->size);
	}
	ret = test_decode(encoded_stream);
	free(encoded_stream);

	return ret;

}
